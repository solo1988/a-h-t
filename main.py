import asyncio
import httpx
import json
import websockets
from datetime import datetime
from pydantic import BaseModel
from steam_api import fetch_game_data, get_achievement_url
from fastapi import FastAPI, Depends, HTTPException, Request, BackgroundTasks, Query, Form
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi.responses import RedirectResponse, HTMLResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from starlette.responses import HTMLResponse, JSONResponse, RedirectResponse
from database import init_db, SessionLocal, SyncSessionLocal
from crud import get_games, get_achievements_for_game, get_game_name, parse_release_date, get_releases
from models import Achievement, Game, PushSubscription, PushSubscriptionCreate, User, Release, Favorite
from sqlalchemy.future import select
from sqlalchemy import or_, cast, String
from sqlalchemy.exc import IntegrityError
import uvicorn
import hashlib
import hmac
import time
from starlette.middleware.sessions import SessionMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
import logging
import sqlite3
from typing import Dict
import requests
from pywebpush import webpush, WebPushException
import os
from dotenv import load_dotenv
from fastapi_login import LoginManager
from fastapi_login.exceptions import InvalidCredentialsException
from passlib.context import CryptContext
from datetime import timedelta
from collections import defaultdict
from calendar import monthrange

if __name__ == "__main__":
    uvicorn.run(
        "main:app",  # —É–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∫ –≤–∞—à–µ–º—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é
        host="127.0.0.1",
        port=8000,
        reload=True,  # –≤–∫–ª—é—á–∏—Ç—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫—É –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–¥–∞
    )

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–∑ .env
load_dotenv()

app = FastAPI()

SECRET_KEY = os.getenv("SECRET_KEY")
# üîë –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–µ—Å—Å–∏–π (–∫–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–µ–∫—Ä–µ—Ç–Ω—ã–º!)
app.add_middleware(SessionMiddleware, SECRET_KEY)
BOT_TOKEN = os.getenv("BOT_TOKEN")
ALLOWED_USER_ID = int(os.getenv("ALLOWED_USER_ID"))

telegram_ids_raw = os.getenv("TELEGRAM_IDS", "")
telegram_ids = [int(tid.strip()) for tid in telegram_ids_raw.split(",") if tid.strip()]

user_ids = [1, 2]
user_to_telegram = dict(zip(user_ids, telegram_ids))

manager = LoginManager(SECRET_KEY, token_url='/login', use_cookie=True)
manager.cookie_name = "auth_token"
manager.lifetime_seconds = 31536000  # 7 –¥–Ω–µ–π = 60 * 60 * 24 * 7

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    filename="app.log",  # –ò–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–æ–≤
    level=logging.INFO,  # –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    format="%(asctime)s - %(levelname)s - %(message)s",  # –§–æ—Ä–º–∞—Ç —Å–æ–æ–±—â–µ–Ω–∏–π
)


@manager.user_loader()
async def load_user(username: str):
    async with SessionLocal() as session:
        result = await session.execute(select(User).where(User.username == username))
        return result.scalar_one_or_none()


@app.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})


@app.post("/login")
async def login(request: Request, username: str = Form(...), password: str = Form(...)):
    user = await load_user(username)
    if not user or not pwd_context.verify(password, user.hashed_password):
        raise InvalidCredentialsException
    token = manager.create_access_token(data={"sub": username}, expires=timedelta(days=365))
    response = RedirectResponse(url="/", status_code=302)
    # manager.set_cookie(response, token)
    response.set_cookie(
        key=manager.cookie_name,
        value=token,
        httponly=True,
        max_age=31536000,  # 1 –≥–æ–¥
        samesite="lax",  # –∏–ª–∏ strict/none –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω—É–∂–¥
        secure=False  # True, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å HTTPS
    )
    return response

class SubscriptionCheckRequest(BaseModel):
    endpoint: str

@app.post("/check_subscription")
async def check_subscription(data: SubscriptionCheckRequest, user=Depends(manager)):
    async with SessionLocal() as db:
        result = await db.execute(
            select(PushSubscription).where(
                PushSubscription.endpoint == data.endpoint,
                PushSubscription.user_id == user.id
            )
        )
        sub = result.scalar_one_or_none()
        return {"exists": sub is not None}

@app.post("/subscribe")
async def subscribe(subscription: PushSubscriptionCreate, user=Depends(manager)):
    async with SessionLocal() as db:
        new_sub = PushSubscription(
            endpoint=subscription.endpoint,
            p256dh=subscription.p256dh,
            auth=subscription.auth,
            user_id=user.id  # –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        )
        db.add(new_sub)
        try:
            await db.commit()
            logging.info(f"–ü–æ–¥–ø–∏—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è user_id={user.id}")
            return {"message": "–ü–æ–¥–ø–∏—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞"}
        except Exception as e:
            await db.rollback()
            logging.error(f"–û—à–∏–±–∫–∞: {e}")
            raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞: {e}")


@app.middleware("http")
async def redirect_unauthed(request: Request, call_next):
    if request.url.path == "/" and not request.cookies.get(manager.cookie_name):
        return RedirectResponse(url="/login")
    response = await call_next(request)
    return response


# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ Jinja2
templates = Jinja2Templates(directory="templates")

# –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã (–¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ —Å—Ç–∏–ª–µ–π)
app.mount("/static", StaticFiles(directory="static"), name="static")


@app.on_event("startup")
async def startup():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    await init_db()
    # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–≥–æ –≤–µ–±-—Å–æ–∫–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
    asyncio.create_task(websocket_listener())

@app.get("/api/steam_appdetails/{appid}")
async def steam_proxy(appid: int):
    url = f"https://store.steampowered.com/api/appdetails?appids={appid}&cc=us&l=ru"
    headers = {
        "Accept-Language": "ru",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
    }
    async with httpx.AsyncClient() as client:
        response = await client.get(url, headers=headers)
    return JSONResponse(content=response.json())

@app.get("/release/{appid}", response_class=HTMLResponse)
async def release_page(request: Request, appid: int, user=Depends(manager)):
    now = datetime.now()

    async with SessionLocal() as session:
        try:
            favorite_appids = await get_user_favorites(user.id, session)
            return templates.TemplateResponse("release.html", {
                "request": request,
                "appid": appid,
                "now": now,
                "favorite_appids": favorite_appids,
                "user": user
            })
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Ä–µ–ª–∏–∑–∞ –¥–ª—è appid={appid}: {str(e)}")
            raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Ä–µ–ª–∏–∑–∞")

MONTHS_MAP = {
    1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun",
    7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"
}

MONTHS_MAP_RUSSIAN = {
    1: "–Ø–Ω–≤–∞—Ä—å", 2: "–§–µ–≤—Ä–∞–ª—å", 3: "–ú–∞—Ä—Ç", 4: "–ê–ø—Ä–µ–ª—å", 5: "–ú–∞–π", 6: "–ò—é–Ω—å",
    7: "–ò—é–ª—å", 8: "–ê–≤–≥—É—Å—Ç", 9: "–°–µ–Ω—Ç—è–±—Ä—å", 10: "–û–∫—Ç—è–±—Ä—å", 11: "–ù–æ—è–±—Ä—å", 12: "–î–µ–∫–∞–±—Ä—å"
}

MONTHS_MAP_REV = {v: k for k, v in MONTHS_MAP.items()}

@app.get("/calendar/{year}/{month}", name="game_calendar")
async def game_calendar(request: Request, year: int = None, month: int = None, user=Depends(manager)):
    logging.info(f"–û—Ç–¥–∞–µ–º —Ä–µ–ª–∏–∑—ã —é–∑–µ—Ä—É: {user.username, user.id}")
    today = datetime.today()
    year = year or today.year
    main_year = today.year
    month = month or today.month
    month_name = MONTHS_MAP.get(month, "Unknown")
    month_name_rus = MONTHS_MAP_RUSSIAN.get(month, "Unknown")

    async with SessionLocal() as session:
        try:
            calendar_data = await get_releases(session, year, month, user.id)
            month_name = MONTHS_MAP.get(month, "Unknown")
            first_day_of_month = datetime(year, month, 1)
            days_in_month = monthrange(year, month)[1]
            now = datetime.now()
            return templates.TemplateResponse("calendar.html", {
                "request": request,
                "calendar_data": calendar_data,  # –ø–µ—Ä–µ–¥–∞–µ–º –∏–º–µ–Ω–Ω–æ calendar_data
                "user": user,
                "datetime": datetime,
                "MONTHS_MAP_REV": MONTHS_MAP_REV,
                "current_year": year,
                "current_month": month_name,
                "month_name": month_name_rus,
                "main_year": main_year,
                "russian_months": MONTHS_MAP_RUSSIAN,
                "current_month_int": month,
                "first_day_of_month": first_day_of_month,
                "days_in_month": days_in_month,
                "now": now
            })
            logging.error(f"–ú–∞—Å—Å–∏–≤ —Ä–µ–ª–∏–∑–æ–≤ {calendar_data}")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∫–∏ —Ä–µ–ª–∏–∑–æ–≤ –¥–ª—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è: {str(e)}")
            print(f"An error occurred while fetching games: {str(e)}")
            raise HTTPException(
                status_code=500, detail=f"Failed to fetch releases data: {str(e)}"
            )

#–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Ä–µ–ª–∏–∑–æ–≤ –ø–æ –¥–Ω—è–º
@app.get("/releases/{year}/{month}/{day}", name="releases_by_day")
async def releases_by_day(request: Request, year: int, month: int, day: int, user=Depends(manager)):
    logging.info(f"–û—Ç–¥–∞–µ–º —Ä–µ–ª–∏–∑—ã –∑–∞ –¥–∞—Ç—É: {day}-{month}-{year} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.username, user.id}")

    try:
        date_str = f"{day:02}.{month:02}.{year}"
        async with SessionLocal() as session:
            calendar_data = await get_releases(session, year, month, user.id)
            target_date = f"{year:04}-{month:02}-{day:02}"

            # –§–∏–ª—å—Ç—Ä—É–µ–º —Ä–µ–ª–∏–∑—ã –ø–æ —Ç–æ—á–Ω–æ —Å–æ–≤–ø–∞–¥–∞—é—â–µ–π –¥–∞—Ç–µ
            releases = calendar_data.get(datetime(year, month, day).date(), [])
            now = datetime.now()
            return templates.TemplateResponse("releases.html", {
                "request": request,
                "user": user,
                "releases": releases,
                "formatted_date": f"{day} {MONTHS_MAP_RUSSIAN.get(month, str(month))} {year}",
                "now": now
            })
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∫–∏ —Ä–µ–ª–∏–∑–æ–≤ –∑–∞ –¥–µ–Ω—å: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–µ–ª–∏–∑–æ–≤ –∑–∞ –¥–∞—Ç—É: {str(e)}"
        )

# –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –≤—ã–≤–æ–¥–æ–º —Å–ø–∏—Å–∫–∞ –∏–≥—Ä
@app.get("/", response_class=HTMLResponse)
async def home(request: Request, user=Depends(manager)):
    logging.info(f"–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω —é–∑–µ—Ä: {user.username, user.id}")
    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
    async with SessionLocal() as session:
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            games = await get_games(
                session, user.id
            )  # –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ get_games –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–≥—Ä
            logging.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–∞ –≥–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –¥–ª—è {user.username}")
            now = datetime.now()
            return templates.TemplateResponse(
                "index.html", {"request": request, "games": games, "user": user, "now": now}
            )
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∫–∏ –∏–≥—Ä –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {str(e)}")
            print(f"An error occurred while fetching games: {str(e)}")
            raise HTTPException(
                status_code=500, detail=f"Failed to fetch games data: {str(e)}"
            )

@app.post("/favorites/{appid}")
async def add_favorite(appid: int, user=Depends(manager)):
    async with SessionLocal() as session:
        try:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–∞—è –∑–∞–ø–∏—Å—å
            stmt = select(Favorite).where(Favorite.user_id == user.id, Favorite.appid == appid)
            result = await session.execute(stmt)
            existing = result.scalar_one_or_none()

            if existing:
                raise HTTPException(status_code=400, detail="–ò–≥—Ä–∞ —É–∂–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º")

            session.add(Favorite(user_id=user.id, appid=appid))
            await session.commit()
            return {"message": "–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ"}
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ: {e}")
            raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞")


@app.delete("/favorites/{appid}")
async def remove_favorite(appid: int, user=Depends(manager)):
    async with SessionLocal() as session:
        try:
            stmt = select(Favorite).where(Favorite.user_id == user.id, Favorite.appid == appid)
            result = await session.execute(stmt)
            favorite = result.scalar_one_or_none()

            if not favorite:
                raise HTTPException(status_code=404, detail="–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º")

            await session.delete(favorite)
            await session.commit()
            return {"message": "–£–¥–∞–ª–µ–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ"}
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ: {e}")
            raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞")


@app.get("/favorites", response_class=HTMLResponse)
async def show_favorites(request: Request, user=Depends(manager)):
    async with SessionLocal() as session:
        try:
            stmt = (
                select(Release)
                .join(Favorite, Favorite.appid == Release.appid)
                .where(Favorite.user_id == user.id)
                # .order_by(Release.release_date)  # –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è —Ç–µ—Å—Ç–∞
            )
            #print(str(stmt.compile(compile_kwargs={"literal_binds": True})))  # –î–ª—è –æ—Ç–ª–∞–¥–∫–∏ SQL
            result = await session.execute(stmt)
            releases = result.scalars().all()
            now = datetime.now()

            return templates.TemplateResponse(
                "favorites.html",
                {"request": request, "releases": releases, "user": user, "now": now}
            )
        except Exception as e:
            import traceback
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ: {e}")
            logging.error(traceback.format_exc())
            raise HTTPException(status_code=500, detail="–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–±—Ä–∞–Ω–Ω–æ–µ")


# –°—Ç—Ä–∞–Ω–∏—Ü–∞ —Å —Ä–∞–∑–¥–∞—á–∞–º–∏
@app.get("/trackers/{appid}", response_class=HTMLResponse)
async def trackers(request: Request, appid: int, user=Depends(manager)):
    async with SessionLocal() as session:
        try:
            game_name = await get_game_name(session, appid, user.id)
            background_url = f"/static/images/background/{appid}.jpg"
            logging.info(f"–§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É —Ä–∞–∑–¥–∞—á –∏–≥—Ä—ã {game_name.name }")
            now = datetime.now()
            return templates.TemplateResponse(
                "trackers.html",
                {
                    "request": request,
                    "appid": appid,
                    "game_name": game_name,
                    "background": background_url,
                    "now": now
                },
            )
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Ä–∞–∑–¥–∞—á: {str(e)}")
            print(f"An error occurred while fetching games: {str(e)}")
            return {"error": "Failed to fetch games data"}


# –°—Ç—Ä–∞–Ω–∏—Ü–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
@app.get("/achievements/{appid}", response_class=HTMLResponse)
async def achievements(request: Request, appid: int, user=Depends(manager)):
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è—Ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    # user_id = request.session.get("user_id")
    # if user_id != ALLOWED_USER_ID:
    #     return RedirectResponse(url="/")
    async with SessionLocal() as session:
        try:
            achievements = await get_achievements_for_game(session, appid, user.id)
            game_name = await get_game_name(session, appid, user.id)
            background_url = f"/static/images/background/{appid}.jpg"
            now = datetime.now()
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            achievements_data = [
                {
                    "name": achievement.displayname,
                    "icon": achievement.icon,
                    "earned": achievement.earned,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–æ–π—Å—Ç–≤–æ earned
                    "link": achievement.icongray,
                    "earned_date": achievement.obtained_date,
                }  # –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ, —Ç–æ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∞ –¥–∞—Ç–∞
                for achievement in achievements
            ]

            logging.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∞—á–∏–≤–æ–∫ –∏–≥—Ä—ã {game_name.name }")
            return templates.TemplateResponse(
                "achievements.html",
                {
                    "request": request,
                    "appid": appid,
                    "achievements": achievements_data,
                    "game_name": game_name,
                    "background": background_url,
                    "now": now
                },
            )
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∫–∏ –∞—á–∏–≤–æ–∫: {str(e)}")
            print(f"An error occurred while fetching games: {str(e)}")
            return {"error": "Failed to fetch games data"}


# –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—É—à–∞

VAPID_PRIVATE_KEY_PATH = os.getenv("VAPID_PRIVATE_KEY_PATH")
VAPID_CLAIMS = {
    "sub": os.getenv("VAPID_CLAIMS")
}


def send_push_notification(subscription, title, body, icon, url):
    payload = {
        "title": title,
        "body": body,
        "icon": icon,
        "url": url
    }

    subscription_info = {
        "endpoint": subscription.endpoint,
        "keys": {
            "p256dh": subscription.p256dh,
            "auth": subscription.auth
        }
    }

    try:
        response = webpush(
            subscription_info=subscription_info,
            data=json.dumps(payload),
            vapid_private_key=VAPID_PRIVATE_KEY_PATH,
            vapid_claims=VAPID_CLAIMS
        )
        logging.info(f"Push –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.–°–æ–¥–µ—Ä–∂–∏–º–æ–µ {payload} –°—Ç–∞—Ç—É—Å: {response.status_code}")
    except WebPushException as ex:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ push: {repr(ex)} | Endpoint: {subscription.endpoint}")

        if "404" in str(ex):
            try:
                with SyncSessionLocal() as db:
                    db_subscription = db.query(PushSubscription).filter_by(endpoint=subscription.endpoint).first()
                    if db_subscription:
                        db.delete(db_subscription)
                        db.commit()
                        logging.info(f"–£–¥–∞–ª–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞ —Å endpoint: {subscription.endpoint}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏: {e}")


class AchievementData(BaseModel):
    appid: int
    achievement_name: str
    obtained_time: int
    user_id: int

#–ø–æ–∏—Å–∫ —Ä–µ–ª–∏–∑–æ–≤
@app.get("/api/search")
async def search_releases(q: str = Query(..., min_length=2)):
    async with SessionLocal() as session:
        # stmt = (
        #     select(Release)
        #     .where(Release.name.ilike(f"%{q}%"))
        #     .where(Release.type == 'game')
        #     .limit(10)
        # )
        stmt = (
            select(Release)
            .where(
                or_(
                    Release.name.ilike(f"%{q}%"),
                    cast(Release.appid, String).ilike(f"%{q}%")
                )
            )
            .where(Release.type == 'game')
            .limit(10)
        )
        result = await session.execute(stmt)
        releases = result.scalars().all()
        return [
            {
                "name": r.name,
                "appid": r.appid,
                "release_date": r.release_date
            }
            for r in releases
        ]

# –≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
@app.post("/api/update_achievement")
async def update_achievement_endpoint(data: AchievementData):
    async with SessionLocal() as session:
        await update_achievement(
            session=session,
            appid=data.appid,
            achievement_name=data.achievement_name,
            obtained_time=data.obtained_time,
            user_id=data.user_id
        )
        logging.info(f"–û—Ç–ø—Ä–∞–≤–∏–ª–∏ –∞—á–∏–≤–∫—É —Å —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –≤–µ–±—Å–æ–∫–µ—Ç–∞, {data.achievement_name}")
        return {"message": "Achievement updated successfully"}


async def get_user_favorites(user_id: int, session: AsyncSession) -> list[int]:
    query = select(Favorite.appid).where(Favorite.user_id == user_id)
    result = await session.execute(query)
    return [row[0] for row in result.fetchall()]


# –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
async def update_achievement(
        session: AsyncSession,
        appid: int,
        achievement_name: str,
        obtained_time: int,
        user_id: int,
):
    obtained_date = datetime.utcfromtimestamp(obtained_time)

    query = select(Achievement).where(
        Achievement.appid == appid,
        Achievement.name == achievement_name,
        Achievement.user_id == user_id
    )
    result = await session.execute(query)
    achievement = result.scalar_one_or_none()

    if achievement:
        achievement.obtained_date = obtained_date
        await session.commit()
        logging.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ {achievement_name}")

        title = achievement.displayname
        body = f"–í—ã –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {achievement_name}!"
        icon = achievement.icon
        url = achievement.icongray

        # –ü—É—à —Ä–∞—Å—Å—ã–ª–∫–∏
        async with SessionLocal() as db:
            subscriptions = await db.execute(
                select(PushSubscription).where(PushSubscription.user_id == user_id)
            )
            for sub in subscriptions.scalars():
                send_push_notification(sub, title, body, icon, url)

        appid = achievement.appid

        # 2. –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã games –ø–æ appid
        result = await db.execute(select(Game).filter(Game.appid == appid).filter(Game.user_id == user_id))
        game = result.scalars().first()

        if game is None:
            return {"error": "–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"}

        game_name = game.name

        title = achievement.displayname
        body = f"–í—ã –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {title}"
        icon = achievement.icon
        url = achievement.icongray

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –∏–≥—Ä—ã
        message = f"–ê—á–∏–≤–∫–∞ –≤ –∏–≥—Ä–µ {game_name }: {title}\n–°—Å—ã–ª–∫–∞: {url}"

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ Telegram
        for tg_user_id, telegram_id in user_to_telegram.items():
            if user_id == tg_user_id:
                send_telegram_message_with_image(telegram_id, message, BOT_TOKEN, icon)
                logging.info(f"–û—Ç–ø—Ä–∞–≤–∏–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º {title}")


async def websocket_listener():
    uri = "ws://192.168.1.111:8082"
    user_id = 1
    while True:
        try:
            async with websockets.connect(uri) as websocket:
                async for message in websocket:
                    data = json.loads(message)
                    async with SessionLocal() as session:
                        # –ü—Ä–∏–±–∞–≤–ª—è–µ–º 3 —á–∞—Å–∞ –ø—Ä—è–º–æ –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –Ω–µ –¥–µ–ª–∞—Ç—å —ç—Ç–æ –≤ update_achievement
                        obtained_time = int(data["time"]) + 3 * 3600  # –î–æ–±–∞–≤–ª—è–µ–º 3 —á–∞—Å–∞ (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)

                        # –ó–¥–µ—Å—å —Å–æ–∑–¥–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
                        asyncio.create_task(update_achievement(
                            session,
                            int(data["appID"]),
                            data["achievement"],
                            obtained_time,
                            user_id
                        ))
                        logging.info("–û—Ç–ø—Ä–∞–≤–∏–ª–∏ –∞—á–∏–≤–∫—É —Å –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –≤–µ–±—Å–æ–∫–µ—Ç–∞")
        except Exception as e:
            # logging.error(f"–û—à–∏–±–∫–∞ –≤–µ–±-—Å–æ–∫–µ—Ç–∞: {e}")
            # print(f"–û—à–∏–±–∫–∞ –≤–µ–±-—Å–æ–∫–µ—Ç–∞: {e}")
            await asyncio.sleep(5)  # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω—ã–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º


@app.post("/add_game")
async def add_game(request: Request, user=Depends(manager)):
    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
    async with SessionLocal() as db:
        # –ß–∏—Ç–∞–µ–º "—Å—ã—Ä—ã–µ" –¥–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        data = await request.json()
        logging.info(f"–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã: {data}")
        print(f"üîç Raw JSON received: {data}")  # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

        try:
            appid = int(data["appid"])  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º appid –≤ int
        except (KeyError, ValueError):
            logging.error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid")
            raise HTTPException(
                status_code=400, detail="–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid"
            )

        logging.info(f"–°–ø–∞—Ä—Å–∏–ª–∏ appid: {appid}")
        print(f"‚úÖ Parsed appid: {appid}")  # –õ–æ–≥–∏—Ä—É–µ–º, –µ—Å–ª–∏ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å

        # –î–∞–ª—å—à–µ –≤—ã–ø–æ–ª–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É:
        existing_game = await db.execute(
            select(Game).filter(Game.appid == appid).filter(Game.user_id == user.id)
        )
        if existing_game.scalar_one_or_none():
            logging.error("–ò–≥—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞")
            raise HTTPException(status_code=400, detail="–ò–≥—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞")

        game_data = await fetch_game_data(appid)
        if not game_data or "game" not in game_data:
            logging.error("–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ Steam")
            raise HTTPException(
                status_code=404, detail="–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ Steam"
            )

        game_name = game_data["game"]["gameName"]

        # –î–æ–±–∞–≤–ª—è–µ–º –∏–≥—Ä—É –≤ –±–∞–∑—É
        new_game = Game(appid=appid, name=game_name, user_id=user.id)
        db.add(new_game)

        achievements = (
            game_data["game"]
            .get("availableGameStats", {})
            .get("achievements", [])
        )
        for ach in achievements:
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è URL –¥–ª—è –∏–∫–æ–Ω–∫–∏
            icongray_url = await get_achievement_url(
                game_name, ach["displayName"]
            )

            achievement = Achievement(
                appid=appid,  # –°—Å—ã–ª–∞–µ–º—Å—è –Ω–∞ appid –∏–≥—Ä—ã
                name=ach["name"],
                displayname=ach["displayName"],
                defaultval=ach.get(
                    "defaultValue", 0
                ),  # –î–æ–±–∞–≤–ª—è–µ–º defaultval, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
                hidden=ach.get("hidden", 0),  # –î–æ–±–∞–≤–ª—è–µ–º hidden, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
                icon=ach.get("icon", ""),  # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–∫–æ–Ω–∫–∞
                icongray=icongray_url,  # –î–æ–±–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –∏–∫–æ–Ω–∫—É
                obtained_date=None,  # –ù–µ –ø–æ–ª—É—á–µ–Ω–æ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ
                user_id=user.id  # –∏–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            )
            db.add(achievement)

        try:
            await db.commit()
            logging.info("–ò–≥—Ä–∞ –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –¥–æ–±–∞–≤–ª–µ–Ω—ã")
            return {"message": "–ò–≥—Ä–∞ –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –¥–æ–±–∞–≤–ª–µ–Ω—ã"}
        except IntegrityError:
            await db.rollback()
            logging.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∏–≥—Ä—ã")
            raise HTTPException(
                status_code=500, detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∏–≥—Ä—ã"
            )


# –ù–∞—Å—Ç—Ä–æ–∏–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
# logging.basicConfig(level=logging.DEBUG)

@app.post("/update_paths")
async def update_paths(request: Request, user=Depends(manager)):
    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
    async with SessionLocal() as db:
        data = await request.json()
        logging.info(f"–ü–æ–ª—É—á–∏–ª–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ –∏–≥—Ä–µ: {data}")
        print(f"üîç Raw JSON received: {data}")  # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        appid = data.get("appid")
        old_substring = data.get("oldSubstring")
        new_substring = data.get("newSubstring")

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
        if not all([appid, old_substring, new_substring]):
            logging.error("–í—Å–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã")
            raise HTTPException(
                status_code=400, detail="–í—Å–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã"
            )

        try:
            appid = int(appid)  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º appid –≤ int
        except ValueError:
            logging.error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid")
            raise HTTPException(
                status_code=400, detail="–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid"
            )

        # –õ–æ–≥–∏—Ä—É–µ–º, –µ—Å–ª–∏ –≤—Å—ë –≤ –ø–æ—Ä—è–¥–∫–µ
        logging.info(f"–°–ø–∞—Ä—Å–∏–ª–∏ —É—Å–ø–µ—à–Ω–æ: {appid}")
        print(f"‚úÖ Parsed appid: {appid}")

        try:
            # –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—É—Ç–µ–π
            query = text(
                """
                UPDATE achievements
                SET icongray = REPLACE(icongray, :old_substring, :new_substring)
                WHERE appid = :appid AND user_id = :user_id
            """
            )
            await db.execute(
                query,
                {
                    "appid": appid,
                    "old_substring": old_substring,
                    "new_substring": new_substring,
                    "user_id": user.id,
                },
            )
            await db.commit()

            logging.info("–ü—É—Ç–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
            return {"success": True, "message": "–ü—É—Ç–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ"}

        except Exception as e:
            logging.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—É—Ç–µ–π: %s", str(e))
            await db.rollback()  # –û—Ç–∫–∞—Ç–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
            raise HTTPException(
                status_code=500,
                detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—É—Ç–µ–π: {str(e)}",
            )


# –ú–æ–¥–µ–ª—å –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
class TestPushNotification(BaseModel):
    title: str
    body: str
    icon: str
    url: str


@app.get("/send_test_notification")
async def send_test_notification():
    # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—É—à-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    achiev_name = "ACH_Branch_BloodyMary"

    async with SessionLocal() as db:
        # 1. –ü–æ–ª—É—á–∞–µ–º appid –∏–∑ —Ç–∞–±–ª–∏—Ü—ã achievements –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        result = await db.execute(
            select(Achievement).where(Achievement.name == achiev_name).where(Achievement.user_id == 1))
        achievement = result.scalars().first()

        if achievement is None:
            return {"error": "–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"}

        appid = achievement.appid

        # 2. –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã games –ø–æ appid
        result = await db.execute(select(Game).filter(Game.appid == appid).filter(Game.user_id == 1))
        game = result.scalars().first()

        if game is None:
            return {"error": "–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"}

        game_name = game.name

        title = achievement.displayname
        body = f"–í—ã –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {title}"
        icon = achievement.icon
        url = achievement.icongray

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –∏–≥—Ä—ã
        message = f"–ê—á–∏–≤–∫–∞ –≤ –∏–≥—Ä–µ {game_name}: {title}\n–°—Å—ã–ª–∫–∞: {url}"

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        subscriptions_result = await db.execute(select(PushSubscription))
        subscriptions = subscriptions_result.scalars().all()

        # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∂–¥–æ–π –ø–æ–¥–ø–∏—Å–∫–µ
        for sub in subscriptions:
            send_push_notification(sub, title, body, icon, url)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ Telegram
        for user_id, telegram_id in user_to_telegram.items():
            send_telegram_message_with_image(telegram_id, message, BOT_TOKEN, icon)
            logging.error(f"–û—Ç–ø—Ä–∞–≤–∏–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º {title} —é–∑–µ—Ä—É {telegram_id}")

    return {"message": "–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ"}


def send_telegram_message_with_image(chat_id: int, message: str, bot_token: str, image_url: str):
    # URL –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ
    url = f"https://api.telegram.org/bot{bot_token}/sendPhoto"

    # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞
    payload = {
        "chat_id": chat_id,
        "caption": message,  # –¢–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        "parse_mode": "HTML",  # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ HTML-—Ä–∞–∑–º–µ—Ç–∫–∏
        "photo": image_url  # URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    }

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
    response = requests.post(url, data=payload)
    logging.info(f"–î–∞–Ω–Ω—ã–µ –≤ —Ç–µ–ª–µ–≥—É {payload}")
    logging.info(f"–ó–∞–ø—Ä–æ—Å –≤ —Ç–µ–ª–µ–≥—É {response}")
    return response
