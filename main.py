import asyncio
import json
import websockets
from datetime import datetime
from pydantic import BaseModel
from steam_api import fetch_game_data, get_achievement_url
from fastapi import FastAPI, Depends, HTTPException, Request, BackgroundTasks, Query, Form
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi.responses import RedirectResponse, HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from starlette.responses import HTMLResponse, JSONResponse, RedirectResponse
from database import init_db, SessionLocal
from crud import get_games, get_achievements_for_game, get_game_name
from models import Achievement, Game, PushSubscription, PushSubscriptionCreate, User
from sqlalchemy.future import select
from sqlalchemy.exc import IntegrityError
import uvicorn
import hashlib
import hmac
import time
from starlette.middleware.sessions import SessionMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
import logging
import sqlite3
from typing import Dict
import requests
from pywebpush import webpush, WebPushException
import os
from dotenv import load_dotenv
from fastapi_login import LoginManager
from fastapi_login.exceptions import InvalidCredentialsException
from passlib.context import CryptContext
from datetime import timedelta

if __name__ == "__main__":
    uvicorn.run(
        "main:app",  # —É–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∫ –≤–∞—à–µ–º—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é
        host="127.0.0.1",
        port=8000,
        reload=True,  # –≤–∫–ª—é—á–∏—Ç—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫—É –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–¥–∞
    )

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–∑ .env
load_dotenv()

app = FastAPI()

SECRET_KEY = os.getenv("SECRET_KEY")
# üîë –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–µ—Å—Å–∏–π (–∫–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–µ–∫—Ä–µ—Ç–Ω—ã–º!)
app.add_middleware(SessionMiddleware, SECRET_KEY)
BOT_TOKEN = os.getenv("BOT_TOKEN")
ALLOWED_USER_ID = int(os.getenv("ALLOWED_USER_ID"))

telegram_ids_raw = os.getenv("TELEGRAM_IDS", "")
telegram_ids = [int(tid.strip()) for tid in telegram_ids_raw.split(",") if tid.strip()]

user_ids = [1, 2]
user_to_telegram = dict(zip(user_ids, telegram_ids))

manager = LoginManager(SECRET_KEY, token_url='/login', use_cookie=True)
manager.cookie_name = "auth_token"
manager.lifetime_seconds = 31536000  # 7 –¥–Ω–µ–π = 60 * 60 * 24 * 7

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    filename="app.log",  # –ò–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–æ–≤
    level=logging.ERROR,  # –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    format="%(asctime)s - %(levelname)s - %(message)s",  # –§–æ—Ä–º–∞—Ç —Å–æ–æ–±—â–µ–Ω–∏–π
)


@manager.user_loader()
async def load_user(username: str):
    async with SessionLocal() as session:
        result = await session.execute(select(User).where(User.username == username))
        return result.scalar_one_or_none()


@app.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

@app.post("/login")
async def login(request: Request, username: str = Form(...), password: str = Form(...)):
    user = await load_user(username)
    if not user or not pwd_context.verify(password, user.hashed_password):
        raise InvalidCredentialsException
    token = manager.create_access_token(data={"sub": username}, expires=timedelta(days=365))
    response = RedirectResponse(url="/", status_code=302)
    # manager.set_cookie(response, token)
    response.set_cookie(
        key=manager.cookie_name,
        value=token,
        httponly=True,
        max_age=31536000,  # 1 –≥–æ–¥
        samesite="lax",    # –∏–ª–∏ strict/none –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω—É–∂–¥
        secure=False       # True, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å HTTPS
    )
    return response


@app.post("/subscribe")
async def subscribe(subscription: PushSubscriptionCreate):
    async with SessionLocal() as db:
        new_sub = PushSubscription(
            endpoint=subscription.endpoint,
            p256dh=subscription.p256dh,
            auth=subscription.auth,
        )
        db.add(new_sub)
        try:
            await db.commit()
            logging.info("–ü–æ–¥–ø–∏—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞")
            return {"message": "–ü–æ–¥–ø–∏—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞"}
        except Exception as e:
            await db.rollback()
            logging.error(f"–û—à–∏–±–∫–∞: {e}")
            raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞: {e}")

@app.middleware("http")
async def redirect_unauthed(request: Request, call_next):
    if request.url.path == "/" and not request.cookies.get(manager.cookie_name):
        return RedirectResponse(url="/login")
    response = await call_next(request)
    return response

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ Jinja2
templates = Jinja2Templates(directory="templates")

# –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã (–¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ —Å—Ç–∏–ª–µ–π)
app.mount("/static", StaticFiles(directory="static"), name="static")


@app.on_event("startup")
async def startup():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    await init_db()
    # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–≥–æ –≤–µ–±-—Å–æ–∫–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
    asyncio.create_task(websocket_listener())


# –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –≤—ã–≤–æ–¥–æ–º —Å–ø–∏—Å–∫–∞ –∏–≥—Ä
@app.get("/", response_class=HTMLResponse)
async def home(request: Request, user=Depends(manager)):
    logging.error(f"–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω —é–∑–µ—Ä: {user.username, user.id}")
    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
    async with SessionLocal() as session:
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            games = await get_games(
                session, user.id
            )  # –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ get_games –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–≥—Ä
            logging.info("–ó–∞–≥—Ä—É–∂–µ–Ω–∞ –≥–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞")
            return templates.TemplateResponse(
                "index.html", {"request": request, "games": games, "user": user}
            )
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∫–∏ –∏–≥—Ä –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {str(e)}")
            print(f"An error occurred while fetching games: {str(e)}")
            raise HTTPException(
                status_code=500, detail=f"Failed to fetch games data: {str(e)}"
            )

# –°—Ç—Ä–∞–Ω–∏—Ü–∞ —Å —Ä–∞–∑–¥–∞—á–∞–º–∏
@app.get("/trackers/{appid}", response_class=HTMLResponse)
async def trackers(request: Request, appid: int, user=Depends(manager)):
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è—Ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    # user_id = request.session.get("user_id")
    # if user_id != ALLOWED_USER_ID:
    #     return RedirectResponse(url="/")
    async with SessionLocal() as session:
        try:
            game_name = await get_game_name(session, appid, user.id)
            background_url = f"/static/images/background/{appid}.jpg"
            logging.info("–§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É —Ä–∞–∑–¥–∞—á")
            return templates.TemplateResponse(
                "trackers.html",
                {
                    "request": request,
                    "appid": appid,
                    "game_name": game_name,
                    "background": background_url,
                },
            )
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Ä–∞–∑–¥–∞—á: {str(e)}")
            print(f"An error occurred while fetching games: {str(e)}")
            return {"error": "Failed to fetch games data"}

# –°—Ç—Ä–∞–Ω–∏—Ü–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
@app.get("/achievements/{appid}", response_class=HTMLResponse)
async def achievements(request: Request, appid: int, user=Depends(manager)):
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è—Ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    # user_id = request.session.get("user_id")
    # if user_id != ALLOWED_USER_ID:
    #     return RedirectResponse(url="/")
    async with SessionLocal() as session:
        try:
            achievements = await get_achievements_for_game(session, appid, user.id)
            game_name = await get_game_name(session, appid, user.id)
            background_url = f"/static/images/background/{appid}.jpg"

            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            achievements_data = [
                {
                    "name": achievement.displayname,
                    "icon": achievement.icon,
                    "earned": achievement.earned,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–æ–π—Å—Ç–≤–æ earned
                    "link": achievement.icongray,
                    "earned_date": achievement.obtained_date,
                }  # –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ, —Ç–æ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∞ –¥–∞—Ç–∞
                for achievement in achievements
            ]

            logging.info("–ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∞—á–∏–≤–æ–∫")
            return templates.TemplateResponse(
                "achievements.html",
                {
                    "request": request,
                    "appid": appid,
                    "achievements": achievements_data,
                    "game_name": game_name,
                    "background": background_url,
                },
            )
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∫–∏ –∞—á–∏–≤–æ–∫: {str(e)}")
            print(f"An error occurred while fetching games: {str(e)}")
            return {"error": "Failed to fetch games data"}


# –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—É—à–∞

VAPID_PRIVATE_KEY_PATH = os.getenv("VAPID_PRIVATE_KEY_PATH")
VAPID_CLAIMS = {
    "sub": os.getenv("VAPID_CLAIMS")
}


def send_push_notification(subscription, title, body, icon, url):
    payload = {
        "title": title,
        "body": body,
        "icon": icon,
        "url": url
    }

    subscription_info = {
        "endpoint": subscription.endpoint,
        "keys": {
            "p256dh": subscription.p256dh,
            "auth": subscription.auth
        }
    }

    try:
        response = webpush(
            subscription_info=subscription_info,
            data=json.dumps(payload),
            vapid_private_key=VAPID_PRIVATE_KEY_PATH,
            vapid_claims=VAPID_CLAIMS
        )
        logging.info(f"Push –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.–°–æ–¥–µ—Ä–∂–∏–º–æ–µ {payload} –°—Ç–∞—Ç—É—Å: {response.status_code}")
    except WebPushException as ex:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ push: {repr(ex)}")

class AchievementData(BaseModel):
    appid: int
    achievement_name: str
    obtained_time: int
    user_id: int

# –≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
@app.post("/api/update_achievement")
async def update_achievement_endpoint(data: AchievementData):
    async with SessionLocal() as session:
        await update_achievement(
            session=session,
            appid=data.appid,
            achievement_name=data.achievement_name,
            obtained_time=data.obtained_time,
            user_id=data.user_id
        )
        return {"message": "Achievement updated successfully"}

# –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
async def update_achievement(
        session: AsyncSession,
        appid: int,
        achievement_name: str,
        obtained_time: int,
        user_id: int,
):
    obtained_date = datetime.utcfromtimestamp(obtained_time)

    query = select(Achievement).where(
        Achievement.appid == appid,
        Achievement.name == achievement_name,
        Achievement.user_id == user_id
    )
    result = await session.execute(query)
    achievement = result.scalar_one_or_none()

    if achievement:
        achievement.obtained_date = obtained_date
        await session.commit()
        logging.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ {achievement_name}")

        title = achievement.displayname
        body = f"–í—ã –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {achievement_name}!"
        icon = achievement.icon
        url = achievement.icongray

        async with SessionLocal() as db:
            subscriptions = await db.execute(select(PushSubscription))
            for sub in subscriptions.scalars():
                send_push_notification(sub, title, body, icon, url)

        appid = achievement.appid

        # 2. –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã games –ø–æ appid
        result = await db.execute(select(Game).filter(Game.appid == appid).filter(Game.user_id == user_id))
        game = result.scalars().first()

        if game is None:
            return {"error": "–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"}

        game_name = game.name

        title = achievement.displayname
        body = f"–í—ã –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {title}"
        icon = achievement.icon
        url = achievement.icongray

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –∏–≥—Ä—ã
        message = f"–ê—á–∏–≤–∫–∞ –≤ –∏–≥—Ä–µ {game_name}: {title}\n–°—Å—ã–ª–∫–∞: {url}"

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        # TODO –ü–æ–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫–∏, –ø—Ä–∏–≤—è–∑–∞—Ç—å –ø–æ –∏–¥
        subscriptions_result = await db.execute(select(PushSubscription))
        subscriptions = subscriptions_result.scalars().all()

        # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∂–¥–æ–π –ø–æ–¥–ø–∏—Å–∫–µ
        for sub in subscriptions:
            send_push_notification(sub, title, body, icon, url)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ Telegram
        # TODO —Å–¥–µ–ª–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –ø–æ –∏–¥ –∏ —Ä–∞—Å—Å—ã–ª–∫—É –æ–±–æ–∏–º –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∏–¥
        for tg_user_id, telegram_id in user_to_telegram.items():
            if(user_id == tg_user_id):
                send_telegram_message_with_image(telegram_id, message, BOT_TOKEN, icon)
                logging.info(f"–û—Ç–ø—Ä–∞–≤–∏–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º {title}")



async def websocket_listener():
    uri = "ws://192.168.1.111:8082"
    user_id = 1
    while True:
        try:
            async with websockets.connect(uri) as websocket:
                async for message in websocket:
                    data = json.loads(message)
                    async with SessionLocal() as session:
                        # –ü—Ä–∏–±–∞–≤–ª—è–µ–º 3 —á–∞—Å–∞ –ø—Ä—è–º–æ –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –Ω–µ –¥–µ–ª–∞—Ç—å —ç—Ç–æ –≤ update_achievement
                        obtained_time = int(data["time"]) + 3 * 3600  # –î–æ–±–∞–≤–ª—è–µ–º 3 —á–∞—Å–∞ (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
                        
                        # –ó–¥–µ—Å—å —Å–æ–∑–¥–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
                        asyncio.create_task(update_achievement(
                            session,
                            int(data["appID"]),
                            data["achievement"],
                            obtained_time,
                            user_id
                        ))
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –≤–µ–±-—Å–æ–∫–µ—Ç–∞: {e}")
            print(f"–û—à–∏–±–∫–∞ –≤–µ–±-—Å–æ–∫–µ—Ç–∞: {e}")
            await asyncio.sleep(5)  # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω—ã–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º

@app.post("/add_game")
async def add_game(request: Request, user=Depends(manager)):
    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
    async with SessionLocal() as db:
        # –ß–∏—Ç–∞–µ–º "—Å—ã—Ä—ã–µ" –¥–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        data = await request.json()
        logging.info(f"–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã: {data}")
        print(f"üîç Raw JSON received: {data}")  # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

        try:
            appid = int(data["appid"])  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º appid –≤ int
        except (KeyError, ValueError):
            logging.error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid")
            raise HTTPException(
                status_code=400, detail="–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid"
            )

        logging.info(f"–°–ø–∞—Ä—Å–∏–ª–∏ appid: {appid}")
        print(f"‚úÖ Parsed appid: {appid}")  # –õ–æ–≥–∏—Ä—É–µ–º, –µ—Å–ª–∏ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å

        # –î–∞–ª—å—à–µ –≤—ã–ø–æ–ª–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É:
        existing_game = await db.execute(
            select(Game).filter(Game.appid == appid).filter(Game.user_id == user.id)
        )
        if existing_game.scalar_one_or_none():
            logging.error("–ò–≥—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞")
            raise HTTPException(status_code=400, detail="–ò–≥—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞")

        game_data = await fetch_game_data(appid)
        if not game_data or "game" not in game_data:
            logging.error("–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ Steam")
            raise HTTPException(
                status_code=404, detail="–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ Steam"
            )

        game_name = game_data["game"]["gameName"]

        # –î–æ–±–∞–≤–ª—è–µ–º –∏–≥—Ä—É –≤ –±–∞–∑—É
        new_game = Game(appid=appid, name=game_name, user_id=user.id)
        db.add(new_game)

        achievements = (
            game_data["game"]
            .get("availableGameStats", {})
            .get("achievements", [])
        )
        for ach in achievements:
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è URL –¥–ª—è –∏–∫–æ–Ω–∫–∏
            icongray_url = await get_achievement_url(
                game_name, ach["displayName"]
            )

            achievement = Achievement(
                appid=appid,  # –°—Å—ã–ª–∞–µ–º—Å—è –Ω–∞ appid –∏–≥—Ä—ã
                name=ach["name"],
                displayname=ach["displayName"],
                defaultval=ach.get(
                    "defaultValue", 0
                ),  # –î–æ–±–∞–≤–ª—è–µ–º defaultval, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
                hidden=ach.get("hidden", 0),  # –î–æ–±–∞–≤–ª—è–µ–º hidden, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
                icon=ach.get("icon", ""),  # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–∫–æ–Ω–∫–∞
                icongray=icongray_url,  # –î–æ–±–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –∏–∫–æ–Ω–∫—É
                obtained_date=None,  # –ù–µ –ø–æ–ª—É—á–µ–Ω–æ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ
                user_id=user.id #–∏–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            )
            db.add(achievement)

        try:
            await db.commit()
            logging.info("–ò–≥—Ä–∞ –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –¥–æ–±–∞–≤–ª–µ–Ω—ã")
            return {"message": "–ò–≥—Ä–∞ –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –¥–æ–±–∞–≤–ª–µ–Ω—ã"}
        except IntegrityError:
            await db.rollback()
            logging.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∏–≥—Ä—ã")
            raise HTTPException(
                status_code=500, detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∏–≥—Ä—ã"
            )


# –ù–∞—Å—Ç—Ä–æ–∏–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
# logging.basicConfig(level=logging.DEBUG)

@app.post("/update_paths")
async def update_paths(request: Request, user=Depends(manager)):
    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
    async with SessionLocal() as db:
        data = await request.json()
        logging.info(f"–ü–æ–ª—É—á–∏–ª–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ –∏–≥—Ä–µ: {data}")
        print(f"üîç Raw JSON received: {data}")  # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        appid = data.get("appid")
        old_substring = data.get("oldSubstring")
        new_substring = data.get("newSubstring")

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
        if not all([appid, old_substring, new_substring]):
            logging.error("–í—Å–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã")
            raise HTTPException(
                status_code=400, detail="–í—Å–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã"
            )

        try:
            appid = int(appid)  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º appid –≤ int
        except ValueError:
            logging.error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid")
            raise HTTPException(
                status_code=400, detail="–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç appid"
            )

        # –õ–æ–≥–∏—Ä—É–µ–º, –µ—Å–ª–∏ –≤—Å—ë –≤ –ø–æ—Ä—è–¥–∫–µ
        logging.info(f"–°–ø–∞—Ä—Å–∏–ª–∏ —É—Å–ø–µ—à–Ω–æ: {appid}")
        print(f"‚úÖ Parsed appid: {appid}")

        try:
            # –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—É—Ç–µ–π
            query = text(
                """
                UPDATE achievements
                SET icongray = REPLACE(icongray, :old_substring, :new_substring)
                WHERE appid = :appid AND user_id = :user_id
            """
            )
            await db.execute(
                query,
                {
                    "appid": appid,
                    "old_substring": old_substring,
                    "new_substring": new_substring,
                    "user_id": user.id,
                },
            )
            await db.commit()

            logging.info("–ü—É—Ç–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
            return {"success": True, "message": "–ü—É—Ç–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ"}

        except Exception as e:
            logging.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—É—Ç–µ–π: %s", str(e))
            await db.rollback()  # –û—Ç–∫–∞—Ç–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
            raise HTTPException(
                status_code=500,
                detail=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—É—Ç–µ–π: {str(e)}",
            )


# –ú–æ–¥–µ–ª—å –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
class TestPushNotification(BaseModel):
    title: str
    body: str
    icon: str
    url: str


@app.get("/send_test_notification")
async def send_test_notification():
    # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—É—à-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    achiev_name = "ACH_Branch_BloodyMary"

    async with SessionLocal() as db:
        # 1. –ü–æ–ª—É—á–∞–µ–º appid –∏–∑ —Ç–∞–±–ª–∏—Ü—ã achievements –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        result = await db.execute(select(Achievement).where(Achievement.name == achiev_name).where(Achievement.user_id == 1))
        achievement = result.scalars().first()

        if achievement is None:
            return {"error": "–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"}

        appid = achievement.appid

        # 2. –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã games –ø–æ appid
        result = await db.execute(select(Game).filter(Game.appid == appid).filter(Game.user_id == 1))
        game = result.scalars().first()

        if game is None:
            return {"error": "–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"}

        game_name = game.name

        title = achievement.displayname
        body = f"–í—ã –ø–æ–ª—É—á–∏–ª–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {title}"
        icon = achievement.icon
        url = achievement.icongray

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –∏–≥—Ä—ã
        message = f"–ê—á–∏–≤–∫–∞ –≤ –∏–≥—Ä–µ {game_name}: {title}\n–°—Å—ã–ª–∫–∞: {url}"

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        subscriptions_result = await db.execute(select(PushSubscription))
        subscriptions = subscriptions_result.scalars().all()

        # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∂–¥–æ–π –ø–æ–¥–ø–∏—Å–∫–µ
        for sub in subscriptions:
            send_push_notification(sub, title, body, icon, url)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ Telegram
        for user_id, telegram_id in user_to_telegram.items():
            send_telegram_message_with_image(telegram_id, message, BOT_TOKEN, icon)
            logging.error(f"–û—Ç–ø—Ä–∞–≤–∏–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º {title} —é–∑–µ—Ä—É {telegram_id}")

    return {"message": "–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ"}


def send_telegram_message_with_image(chat_id: str, message: str, bot_token: str, image_url: str):
    # URL –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ
    url = f"https://api.telegram.org/bot{bot_token}/sendPhoto"

    # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞
    payload = {
        "chat_id": chat_id,
        "caption": message,  # –¢–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        "parse_mode": "HTML",  # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ HTML-—Ä–∞–∑–º–µ—Ç–∫–∏
        "photo": image_url  # URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    }

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
    response = requests.post(url, data=payload)
    logging.info(f"–î–∞–Ω–Ω—ã–µ –≤ —Ç–µ–ª–µ–≥—É {payload}")
    logging.info(f"–ó–∞–ø—Ä–æ—Å –≤ —Ç–µ–ª–µ–≥—É {response}")
    return response
